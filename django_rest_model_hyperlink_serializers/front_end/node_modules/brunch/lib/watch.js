// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var BrunchWatcher, bindWatcherEvents, changeFileList, changedSince, chokidar, debug, each, fs_utils, generateCompilationLog, generateParams, getCompileFn, getPluginIncludes, getPlugins, getReloadFn, helpers, initWatcher, initialize, isConfigFile, isPluginFor, loadPackages, logger, propIsFunction, pushserve, startServer, sysPath, watch,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  each = require('async-each');

  chokidar = require('chokidar');

  debug = require('debug')('brunch:watch');

  sysPath = require('path');

  logger = require('loggy');

  pushserve = require('pushserve');

  fs_utils = require('./fs_utils');

  helpers = require('./helpers');

  getPluginIncludes = function(plugins) {
    var ensureArray, getValue;
    getValue = function(thing, context) {
      if (context == null) {
        context = this;
      }
      if (typeof thing === 'function') {
        return thing.call(context);
      } else {
        return thing;
      }
    };
    ensureArray = function(object) {
      if (Array.isArray(object)) {
        return object;
      } else {
        return [object];
      }
    };
    return plugins.map(function(plugin) {
      return getValue(plugin.include, plugin);
    }).filter(function(paths) {
      return paths != null;
    }).reduce((function(acc, elem) {
      return acc.concat(ensureArray(elem));
    }), []);
  };

  propIsFunction = function(prop) {
    return function(object) {
      return typeof object[prop] === 'function';
    };
  };

  generateParams = function(persistent, options) {
    var params;
    params = {};
    if (options.optimize != null) {
      params.optimize = options.optimize;
    }
    params.persistent = persistent;
    if (options.publicPath) {
      params.paths = {};
      params.paths["public"] = options.publicPath;
    }
    if (persistent) {
      params.server = {};
      if (options.server) {
        params.server.run = true;
      }
      if (options.port) {
        params.server.port = options.port;
      }
    }
    return params;
  };

  startServer = function(config, callback) {
    var error, log, opts, port, publicPath, server, serverOpts;
    if (callback == null) {
      callback = (function() {});
    }
    serverOpts = config.server || {};
    port = parseInt(config.server.port, 10);
    publicPath = config.paths["public"];
    log = function() {
      logger.info("application started on http://localhost:" + port + "/");
      return callback();
    };
    if (config.server.path) {
      try {
        server = require(sysPath.resolve(config.server.path));
      } catch (_error) {
        error = _error;
        logger.error("couldn\'t load server " + config.server.path + ": " + error);
      }
      if (server.startServer == null) {
        throw new Error('Brunch server file needs to have startServer function');
      }
      return server.startServer(port, publicPath, log);
    } else {
      opts = {
        noLog: true,
        path: publicPath
      };
      return pushserve(helpers.extend(opts, serverOpts), log);
    }
  };

  initWatcher = function(config, callback) {
    var exists, watched;
    watched = config.paths.watched.concat([config.paths.config, config.paths.packageConfig]);
    watched = watched.concat.apply(watched, config._normalized.bowerComponents.map(function(_) {
      return _.files;
    }));
    Object.keys(require.extensions).forEach(function(ext) {
      return watched.push(config.paths.config + ext);
    });
    exists = function(path, callback) {
      return fs_utils.exists(path, function(value) {
        return callback(void 0, value);
      });
    };
    return each(watched, exists, function(err, existing) {
      var params, watchedFiles;
      watchedFiles = watched.filter(function(_, index) {
        return existing[index];
      });
      params = {
        ignored: fs_utils.ignored,
        persistent: config.persistent
      };
      return callback(null, chokidar.watch(watchedFiles, params));
    });
  };

  isPluginFor = function(path) {
    return function(plugin) {
      var pattern;
      pattern = plugin.pattern ? plugin.pattern : plugin.extension ? RegExp("\\." + plugin.extension + "$") : /$.^/;
      return pattern.test(path);
    };
  };

  changeFileList = function(compilers, linters, fileList, path, isHelper) {
    var compiler, currentLinters;
    compiler = compilers.filter(isPluginFor(path));
    currentLinters = linters.filter(isPluginFor(path));
    return fileList.emit('change', path, compiler, currentLinters, isHelper);
  };

  changedSince = function(startTime) {
    return function(generated) {
      return generated.sourceFiles.some(function(sourceFile) {
        return sourceFile.compilationTime >= startTime || sourceFile.removed;
      });
    };
  };

  generateCompilationLog = function(startTime, allAssets, generatedFiles) {
    var assetsLog, cachedCount, cachedCountName, cachedLog, compiled, compiledCount, compiledLog, copied, copiedCount, generated, generatedLog, getName, main, nonAssetsLog, sep;
    getName = function(file) {
      return sysPath.basename(file.path);
    };
    copied = allAssets.filter(function(_) {
      return _.copyTime > startTime;
    }).map(getName);
    generated = [];
    compiled = [];
    cachedCount = 0;
    generatedFiles.forEach(function(generatedFile) {
      var isChanged, locallyCompiledCount;
      isChanged = false;
      locallyCompiledCount = 0;
      generatedFile.sourceFiles.forEach(function(sourceFile) {
        var sourceName;
        if (sourceFile.compilationTime >= startTime) {
          isChanged = true;
          locallyCompiledCount += 1;
          sourceName = getName(sourceFile);
          if (__indexOf.call(compiled, sourceName) < 0) {
            return compiled.push(sourceName);
          }
        }
      });
      if (isChanged) {
        generated.push(getName(generatedFile));
        return cachedCount += generatedFile.sourceFiles.length - locallyCompiledCount;
      }
    });
    compiledCount = compiled.length;
    copiedCount = copied.length;
    generatedLog = (function() {
      switch (generated.length) {
        case 0:
          return '';
        case 1:
          return " into " + generated[0];
        default:
          return " into " + generated.length + " files";
      }
    })();
    compiledLog = (function() {
      switch (compiledCount) {
        case 0:
          return '';
        case 1:
          return "compiled " + compiled[0];
        default:
          return "compiled " + compiled.length;
      }
    })();
    cachedLog = (function() {
      switch (cachedCount) {
        case 0:
          if (compiledCount === 0 || compiledCount === 1) {
            return '';
          } else {
            return ' files';
          }
          break;
        default:
          if (compiledCount === 1) {
            cachedCountName = "file" + (cachedCount === 1 ? '' : 's');
            return " and " + cachedCount + " cached " + cachedCountName;
          } else {
            return " files and " + cachedCount + " cached";
          }
      }
    })();
    nonAssetsLog = compiledLog + cachedLog + generatedLog;
    sep = nonAssetsLog && copiedCount !== 0 ? ', ' : '';
    assetsLog = (function() {
      switch (copiedCount) {
        case 0:
          return '';
        case 1:
          return "copied " + copied[0];
        default:
          if (compiled.length === 0) {
            return "copied " + copiedCount + " files";
          } else {
            return "copied " + copiedCount;
          }
      }
    })();
    main = nonAssetsLog + sep + assetsLog;
    return "" + (main ? main : 'compiled') + " in " + (Date.now() - startTime) + "ms";
  };

  getCompileFn = function(config, joinConfig, fileList, optimizers, watcher, callback) {
    return function(startTime) {
      var assetErrors;
      assetErrors = fileList.getAssetErrors();
      if (assetErrors != null) {
        assetErrors.forEach(function(error) {
          return logger.error(error);
        });
        return;
      }
      return fs_utils.write(fileList, config, joinConfig, optimizers, startTime, function(error, generatedFiles) {
        if (error != null) {
          if (Array.isArray(error)) {
            error.forEach(function(subError) {
              return logger.error(subError);
            });
          } else {
            logger.error(error);
          }
        } else {
          logger.info(generateCompilationLog(startTime, fileList.assets, generatedFiles));
        }
        if (!config.persistent) {
          watcher.close();
          process.on('exit', function(previousCode) {
            return process.exit((logger.errorHappened ? 1 : previousCode));
          });
        }
        fileList.initial = false;
        if (error != null) {
          return;
        }
        return callback(generatedFiles);
      });
    };
  };

  getReloadFn = function(config, options, onCompile, watcher, server, plugins) {
    return function(reInstall) {
      var reWatch;
      reWatch = function() {
        var restart;
        restart = function() {
          watcher.close();
          return watch(config.persistent, options, onCompile);
        };
        plugins.forEach(function(plugin) {
          return typeof plugin.teardown === "function" ? plugin.teardown() : void 0;
        });
        if ((server != null ? server.close : void 0) != null) {
          return server.close(restart);
        } else {
          return restart();
        }
      };
      if (reInstall) {
        return helpers.install(config.paths.root, reWatch);
      } else {
        logger.info("Reloading watcher...");
        return reWatch();
      }
    };
  };

  getPlugins = function(packages, config) {
    return packages.filter(function(plugin) {
      var _ref;
      return (_ref = plugin.prototype) != null ? _ref.brunchPlugin : void 0;
    }).map(function(plugin) {
      return new plugin(config);
    });
  };

  loadPackages = function(rootPath, callback) {
    var devPlugins, err, json, loadDeps, nodeModules, packagePath, plugins;
    rootPath = sysPath.resolve(rootPath);
    nodeModules = "" + rootPath + "/node_modules";
    try {
      packagePath = sysPath.join(rootPath, 'package.json');
      delete require.cache[require.resolve(packagePath)];
      json = require(packagePath);
    } catch (_error) {
      err = _error;
      throw new Error("Current directory is not brunch application root path, as it does not contain package.json (" + err + ")");
    }
    loadDeps = function(deps, isDev) {
      return deps.filter(function(dependency) {
        return dependency !== 'brunch' && dependency.indexOf('brunch') !== -1;
      }).map(function(dependency) {
        var depPath, e, error;
        depPath = "" + nodeModules + "/" + dependency;
        if (isDev) {
          try {
            return require(depPath);
          } catch (_error) {
            e = _error;
            return null;
          }
        } else {
          try {
            return require(depPath);
          } catch (_error) {
            error = _error;
            throw new Error("You probably need to execute `npm install` to install brunch plugins. " + error);
          }
        }
      });
    };
    plugins = loadDeps(Object.keys(json.dependencies));
    devPlugins = loadDeps(Object.keys(json.devDependencies || {}), true);
    return plugins.concat(devPlugins.filter(function(_) {
      return _ != null;
    }));
  };

  initialize = function(options, configParams, onCompile, callback) {
    var packages;
    packages = loadPackages('.');
    return helpers.loadConfig(options.config, configParams, function(error, config) {
      var callCompileCallbacks, callbacks, compilers, fileList, joinConfig, linters, optimizers, plugins, server;
      joinConfig = config._normalized.join;
      plugins = getPlugins(packages, config);
      compilers = plugins.filter(propIsFunction('compile'));
      compilers.forEach(function(_) {
        var fn;
        return _._compile = _.compile.length === 2 ? _.compile : (fn = _.compile.bind(_), function(params, callback) {
          return fn(params.data, params.path, function(error, params) {
            var result;
            if (error != null) {
              return callback(error);
            }
            result = typeof params === 'object' ? params : {
              data: params
            };
            return callback(null, result);
          });
        });
      });
      linters = plugins.filter(propIsFunction('lint'));
      optimizers = plugins.filter(propIsFunction('optimize')).concat(plugins.filter(propIsFunction('minify')));
      optimizers.forEach(function(_) {
        var fn, _ref;
        return _._optimize = ((_ref = _.optimize) != null ? _ref.length : void 0) === 2 ? _.optimize : (fn = (_.optimize || _.minify).bind(_), function(params, callback) {
          return fn(params.data, params.path, function(error, params) {
            var result;
            if (error != null) {
              return callback(error);
            }
            result = typeof params === 'object' ? params : {
              data: params
            };
            return callback(null, result);
          });
        });
      });
      callbacks = plugins.filter(propIsFunction('onCompile')).map(function(plugin) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return plugin.onCompile.apply(plugin, args);
        };
      });
      callbacks.push(onCompile);
      callCompileCallbacks = function(generatedFiles) {
        return callbacks.forEach(function(callback) {
          return callback(generatedFiles);
        });
      };
      fileList = new fs_utils.FileList(config);
      if (config.persistent && config.server.run) {
        server = startServer(config);
      }
      return initWatcher(config, function(error, watcher) {
        var compile, includes, reload;
        if (error != null) {
          return callback(error);
        }
        compile = getCompileFn(config, joinConfig, fileList, optimizers, watcher, callCompileCallbacks);
        reload = getReloadFn(config, options, onCompile, watcher, server, plugins);
        includes = getPluginIncludes(plugins);
        return callback(error, {
          config: config,
          watcher: watcher,
          server: server,
          fileList: fileList,
          compilers: compilers,
          linters: linters,
          compile: compile,
          reload: reload,
          includes: includes
        });
      });
    });
  };

  isConfigFile = function(basename, configPath) {
    var files;
    files = Object.keys(require.extensions).map(function(_) {
      return configPath + _;
    });
    return files.some(function(file) {
      return basename === file;
    });
  };

  bindWatcherEvents = function(config, fileList, compilers, linters, watcher, reload, onChange) {
    var possibleConfigFiles;
    possibleConfigFiles = Object.keys(require.extensions).map(function(_) {
      return config.paths.config + _;
    }).reduce(function(obj, _) {
      obj[_] = true;
      return obj;
    }, {});
    watcher.on('error', logger.error).on('add', function(path) {
      var isPluginsFile;
      isConfigFile = possibleConfigFiles[path];
      isPluginsFile = path === config.paths.packageConfig;
      if (!(isConfigFile || isPluginsFile)) {
        onChange();
        return changeFileList(compilers, linters, fileList, path, false);
      }
    }).on('change', function(path) {
      var isPluginsFile;
      isConfigFile = possibleConfigFiles[path];
      isPluginsFile = path === config.paths.packageConfig;
      if (isConfigFile || isPluginsFile) {
        return reload(isPluginsFile);
      } else {
        onChange();
        return changeFileList(compilers, linters, fileList, path, false);
      }
    }).on('unlink', function(path) {
      var isPluginsFile;
      isConfigFile = possibleConfigFiles[path];
      isPluginsFile = path === config.paths.packageConfig;
      if (isConfigFile || isPluginsFile) {
        logger.info("Detected removal of config.coffee / package.json.Exiting.");
        return process.exit(0);
      } else {
        onChange();
        return fileList.emit('unlink', path);
      }
    });
    if (process.env.DEBUG) {
      return watcher.on('all', function(event, path) {
        return debug("File '" + path + "' received event '" + event + "'");
      });
    }
  };

  BrunchWatcher = (function() {
    function BrunchWatcher(persistent, options, onCompile) {
      this._endCompilation = __bind(this._endCompilation, this);
      this._startCompilation = __bind(this._startCompilation, this);
      var configParams,
        _this = this;
      configParams = generateParams(persistent, options);
      initialize(options, configParams, onCompile, function(error, result) {
        var compile, compilers, config, fileList, includes, linters, reload, watcher;
        if (error != null) {
          return logger.error(error);
        }
        config = result.config, watcher = result.watcher, fileList = result.fileList, compilers = result.compilers, linters = result.linters, compile = result.compile, reload = result.reload, includes = result.includes;
        logger.notifications = config.notifications;
        logger.notificationsTitle = config.notificationsTitle || 'Brunch';
        bindWatcherEvents(config, fileList, compilers, linters, watcher, reload, _this._startCompilation);
        fileList.on('ready', function() {
          return compile(_this._endCompilation());
        });
        _this.config = config;
        return includes.forEach(function(path) {
          return changeFileList(compilers, linters, fileList, path, true);
        });
      });
    }

    BrunchWatcher.prototype._startCompilation = function() {
      return this._start != null ? this._start : this._start = Date.now();
    };

    BrunchWatcher.prototype._endCompilation = function() {
      var start;
      start = this._start;
      this._start = null;
      return start;
    };

    return BrunchWatcher;

  })();

  module.exports = watch = function(persistent, options, callback) {
    if (callback == null) {
      callback = (function() {});
    }
    return new BrunchWatcher(persistent, options, callback);
  };

}).call(this);
