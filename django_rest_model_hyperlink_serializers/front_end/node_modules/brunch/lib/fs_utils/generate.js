// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var SourceMapConsumer, SourceMapGenerator, SourceNode, common, concat, debug, extractOrder, flatten, fs, generate, optimize, sort, sortAlphabetically, sortBowerComponents, sortByAfter, sortByBefore, sortByConfig, sortByVendor, sysPath, waterfall, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  debug = require('debug')('brunch:generate');

  fs = require('fs');

  sysPath = require('path');

  waterfall = require('async-waterfall');

  common = require('./common');

  _ref = require('source-map'), SourceMapConsumer = _ref.SourceMapConsumer, SourceMapGenerator = _ref.SourceMapGenerator, SourceNode = _ref.SourceNode;

  sortAlphabetically = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };

  sortByVendor = function(config, a, b) {
    var aIsVendor, bIsVendor;
    aIsVendor = config.vendorConvention(a);
    bIsVendor = config.vendorConvention(b);
    if (aIsVendor && !bIsVendor) {
      return -1;
    } else if (!aIsVendor && bIsVendor) {
      return 1;
    } else {
      return sortAlphabetically(a, b);
    }
  };

  sortByAfter = function(config, a, b) {
    var hasA, hasB, indexOfA, indexOfB, _ref1;
    indexOfA = config.after.indexOf(a);
    indexOfB = config.after.indexOf(b);
    _ref1 = [indexOfA !== -1, indexOfB !== -1], hasA = _ref1[0], hasB = _ref1[1];
    if (hasA && !hasB) {
      return 1;
    } else if (!hasA && hasB) {
      return -1;
    } else if (hasA && hasB) {
      return indexOfA - indexOfB;
    } else {
      return sortByVendor(config, a, b);
    }
  };

  sortByBefore = function(config, a, b) {
    var hasA, hasB, indexOfA, indexOfB, _ref1;
    indexOfA = config.before.indexOf(a);
    indexOfB = config.before.indexOf(b);
    _ref1 = [indexOfA !== -1, indexOfB !== -1], hasA = _ref1[0], hasB = _ref1[1];
    if (hasA && !hasB) {
      return -1;
    } else if (!hasA && hasB) {
      return 1;
    } else if (hasA && hasB) {
      return indexOfA - indexOfB;
    } else {
      return sortByAfter(config, a, b);
    }
  };

  sortBowerComponents = function(config, a, b) {
    var aLevel, bLevel;
    aLevel = config.bowerMapping[a];
    bLevel = config.bowerMapping[b];
    if ((aLevel != null) && (bLevel == null)) {
      return -1;
    } else if ((aLevel == null) && (bLevel != null)) {
      return 1;
    } else if ((aLevel != null) && (bLevel != null)) {
      return bLevel - aLevel;
    } else {
      return sortByBefore(config, a, b);
    }
  };

  sortByConfig = function(files, config) {
    var cfg, _ref1, _ref2, _ref3, _ref4;
    if (toString.call(config) === '[object Object]') {
      cfg = {
        before: (_ref1 = config.before) != null ? _ref1 : [],
        after: (_ref2 = config.after) != null ? _ref2 : [],
        vendorConvention: (_ref3 = config.vendorConvention) != null ? _ref3 : function() {
          return false;
        },
        bowerMapping: (_ref4 = config.bowerMapping) != null ? _ref4 : {}
      };
      return files.slice().sort(function(a, b) {
        return sortBowerComponents(cfg, a, b);
      });
    } else {
      return files;
    }
  };

  flatten = function(array) {
    return array.reduce(function(acc, elem) {
      return acc.concat(Array.isArray(elem) ? flatten(elem) : [elem]);
    }, []);
  };

  extractOrder = function(files, config) {
    var after, before, orders, types, vendorConvention;
    types = files.map(function(file) {
      return file.type + 's';
    });
    orders = Object.keys(config.files).filter(function(key) {
      return __indexOf.call(types, key) >= 0;
    }).map(function(key) {
      var _ref1;
      return (_ref1 = config.files[key].order) != null ? _ref1 : {};
    });
    before = flatten(orders.map(function(type) {
      var _ref1;
      return (_ref1 = type.before) != null ? _ref1 : [];
    }));
    after = flatten(orders.map(function(type) {
      var _ref1;
      return (_ref1 = type.after) != null ? _ref1 : [];
    }));
    vendorConvention = config._normalized.conventions.vendor;
    return {
      before: before,
      after: after,
      vendorConvention: vendorConvention,
      bowerMapping: config._normalized.bowerFilesMap
    };
  };

  sort = function(files, config) {
    var indexes, order, paths;
    paths = files.map(function(file) {
      return file.path;
    });
    indexes = Object.create(null);
    files.forEach(function(file, index) {
      return indexes[file.path] = file;
    });
    order = extractOrder(files, config);
    return sortByConfig(paths, order).map(function(path) {
      return indexes[path];
    });
  };

  concat = function(files, path, type, definition) {
    var root;
    root = new SourceNode();
    debug("Concatenating " + (files.map(function(_) {
      return _.path;
    }).join(', ')) + " to " + path);
    files.forEach(function(file) {
      root.add(file.node);
      return root.setSourceContent(file.node.source, file.source);
    });
    if (type === 'javascript') {
      root.prepend(definition());
    }
    return root.toStringWithSourceMap({
      file: path
    });
  };

  optimize = function(data, prevMap, path, optimizers, isEnabled, callback) {
    var chained, initial;
    initial = {
      data: data,
      code: data,
      path: path,
      map: prevMap
    };
    if (!isEnabled) {
      return callback(null, initial);
    }
    chained = optimizers.map(function(optimizer) {
      return function(params, next) {
        return optimizer._optimize(params, function(error, optimized) {
          var code, json, map, newMap, result, smConsumer;
          if (error != null) {
            return next(error);
          }
          code = optimized.data;
          map = optimized.map;
          if (map != null) {
            json = params.map.toJSON();
            smConsumer = new SourceMapConsumer(json);
            newMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(map));
            newMap._sources.add(path);
            newMap._mappings.forEach(function(mapping) {
              return mapping.source = path;
            });
            if (newMap._sourcesContents == null) {
              newMap._sourcesContents = {};
            }
            newMap._sourcesContents["$" + path] = '';
            newMap.applySourceMap(smConsumer);
          } else {
            newMap = params.map;
          }
          result = code;
          return next(error, {
            data: code,
            code: code,
            map: newMap
          });
        });
      };
    });
    chained.unshift(function(next) {
      return next(null, initial);
    });
    return waterfall(chained, callback);
  };

  generate = function(path, sourceFiles, config, optimizers, callback) {
    var code, map, mapPath, sorted, type, withMaps, _ref1;
    type = sourceFiles.some(function(file) {
      return file.type === 'javascript';
    }) ? 'javascript' : 'stylesheet';
    optimizers = optimizers.filter(function(optimizer) {
      return optimizer.type === type;
    });
    sorted = sort(sourceFiles, config);
    _ref1 = concat(sorted, path, type, config._normalized.modules.definition), code = _ref1.code, map = _ref1.map;
    withMaps = map && config.sourceMaps;
    mapPath = "" + path + ".map";
    return optimize(code, map, path, optimizers, config.optimize, function(error, data) {
      var base, controlChar;
      if (error != null) {
        return callback(error);
      }
      if (withMaps) {
        base = sysPath.basename(mapPath);
        controlChar = config.sourceMaps === 'new' ? '#' : '@';
        data.code += type === 'javascript' ? "\n//" + controlChar + " sourceMappingURL=" + base : "\n/*" + controlChar + " sourceMappingURL=" + base + "*/";
      }
      return common.writeFile(path, data.code, function() {
        if (withMaps) {
          return common.writeFile(mapPath, data.map.toString(), callback);
        } else {
          return callback();
        }
      });
    });
  };

  generate.sortByConfig = sortByConfig;

  module.exports = generate;

}).call(this);
