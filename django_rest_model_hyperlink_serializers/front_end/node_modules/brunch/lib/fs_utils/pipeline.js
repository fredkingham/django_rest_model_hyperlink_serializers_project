// Generated by CoffeeScript 1.6.3
(function() {
  var compile, debug, each, fs, getDependencies, lint, logger, pipeline, throwError, waterfall,
    _this = this;

  each = require('async-each');

  waterfall = require('async-waterfall');

  debug = require('debug')('brunch:pipeline');

  fs = require('fs');

  logger = require('loggy');

  throwError = function(type, stringOrError) {
    var error, string;
    string = stringOrError instanceof Error ? stringOrError.toString().replace(/^([^:]+:\s+)/, '') : stringOrError;
    error = new Error(string);
    error.brunchType = type;
    return error;
  };

  lint = function(data, path, linters, callback) {
    if (linters.length === 0) {
      return callback(null);
    } else {
      return each(linters, function(linter, callback) {
        return linter.lint(data, path, callback);
      }, callback);
    }
  };

  getDependencies = function(data, path, compiler, callback) {
    if (compiler.getDependencies) {
      return compiler.getDependencies(data, path, callback);
    } else {
      return callback(null, []);
    }
  };

  compile = function(initialData, path, compilers, callback) {
    var chained,
      _this = this;
    chained = compilers.map(function(compiler) {
      var compilerName;
      compilerName = compiler.constructor.name;
      return function(params, next) {
        var compiled, dependencies, source, sourceMap;
        if (!params) {
          return next();
        }
        dependencies = params.dependencies, compiled = params.compiled, source = params.source, sourceMap = params.sourceMap, path = params.path;
        debug("Compiling '" + path + "' with '" + compilerName + "'");
        return compiler._compile({
          data: compiled || source,
          path: path
        }, function(error, result) {
          var _this = this;
          if (error != null) {
            return callback(throwError('Compiling', error));
          }
          if (result == null) {
            return next();
          }
          if (result.map != null) {
            sourceMap = result.map;
          }
          compiled = result.data;
          if (compiled == null) {
            throw new Error("Brunch SourceFile: file " + path + " data is invalid");
          }
          debug("getDependencies '" + path + "' with '" + compilerName + "'");
          return getDependencies(source, path, compiler, function(error, dependencies) {
            if (error != null) {
              return callback(throwError('Dependency parsing', error));
            }
            return next(null, {
              dependencies: dependencies,
              compiled: compiled,
              source: source,
              sourceMap: sourceMap,
              path: path
            });
          });
        });
      };
    });
    chained.unshift(function(next) {
      return next(null, {
        source: initialData,
        path: path
      });
    });
    return waterfall(chained, callback);
  };

  pipeline = function(realPath, path, linters, compilers, callback) {
    debug("Reading '" + path + "'");
    return fs.readFile(realPath, 'utf-8', function(error, source) {
      if (error != null) {
        return callback(throwError('Reading', error));
      }
      debug("Linting '" + path + "'");
      return lint(source, path, linters, function(error) {
        if (error != null ? error.match(/^warn\:\s/i) : void 0) {
          return logger.warn("Linting of " + path + ": " + error);
        } else {
          if (error != null) {
            return callback(throwError('Linting', error));
          }
          return compile(source, path, compilers, callback);
        }
      });
    });
  };

  exports.pipeline = pipeline;

}).call(this);
