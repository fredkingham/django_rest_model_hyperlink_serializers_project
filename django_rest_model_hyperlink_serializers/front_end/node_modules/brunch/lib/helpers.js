// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var SourceNode, cleanModuleName, commonRequireDefinition, createJoinConfig, debug, deepFreeze, exec, extend, fs, getConfigDeprecations, getModuleWrapper, http, identityNode, install, logger, normalizeChecker, normalizeConfig, normalizeDefinition, normalizeWrapper, os, readComponents, recursiveExtend, replaceBackSlashes, replaceConfigSlashes, replaceSlashes, setConfigDefaults, sysPath;

  exec = require('child_process').exec;

  http = require('http');

  fs = require('fs');

  os = require('os');

  sysPath = require('path');

  logger = require('loggy');

  SourceNode = require('source-map').SourceNode;

  readComponents = require('read-components');

  debug = require('debug')('brunch:helpers');

  commonRequireDefinition = require('commonjs-require-definition');

  require('coffee-script');

  exports.extend = extend = function(object, properties) {
    Object.keys(properties).forEach(function(key) {
      return object[key] = properties[key];
    });
    return object;
  };

  recursiveExtend = function(object, properties) {
    Object.keys(properties).forEach(function(key) {
      var value;
      value = properties[key];
      if (typeof value === 'object' && (value != null)) {
        return recursiveExtend(object[key], value);
      } else {
        return object[key] = value;
      }
    });
    return object;
  };

  exports.deepFreeze = deepFreeze = function(object) {
    Object.keys(Object.freeze(object)).map(function(key) {
      return object[key];
    }).filter(function(value) {
      return typeof value === 'object' && (value != null) && !Object.isFrozen(value);
    }).forEach(deepFreeze);
    return object;
  };

  exports.formatError = function(error, path) {
    return "" + error.brunchType + " of '" + path + "' failed. " + (error.toString().slice(7));
  };

  exports.install = install = function(rootPath, callback) {
    var prevDir;
    if (callback == null) {
      callback = (function() {});
    }
    prevDir = process.cwd();
    logger.info('Installing packages...');
    process.chdir(rootPath);
    return exec('npm install', function(error, stdout, stderr) {
      var log;
      process.chdir(prevDir);
      if (error != null) {
        log = stderr.toString();
        logger.error(log);
        return callback(log);
      }
      return callback(null, stdout);
    });
  };

  exports.replaceSlashes = replaceSlashes = (function() {
    if (os.platform() === 'win32') {
      return function(_) {
        return _.replace(/\//g, '\\');
      };
    } else {
      return function(_) {
        return _;
      };
    }
  })();

  exports.replaceBackSlashes = replaceBackSlashes = (function() {
    if (os.platform() === 'win32') {
      return function(_) {
        return _.replace(/\\/g, '\/');
      };
    } else {
      return function(_) {
        return _;
      };
    }
  })();

  exports.replaceConfigSlashes = replaceConfigSlashes = function(config) {
    var files;
    files = config.files || {};
    Object.keys(files).forEach(function(language) {
      var lang, newJoinTo, order;
      lang = files[language] || {};
      order = lang.order || {};
      Object.keys(order).forEach(function(orderKey) {
        return lang.order[orderKey] = lang.order[orderKey].map(replaceSlashes);
      });
      switch (toString.call(lang.joinTo)) {
        case '[object String]':
          return lang.joinTo = replaceSlashes(lang.joinTo);
        case '[object Object]':
          newJoinTo = {};
          Object.keys(lang.joinTo).forEach(function(joinToKey) {
            return newJoinTo[replaceSlashes(joinToKey)] = lang.joinTo[joinToKey];
          });
          return lang.joinTo = newJoinTo;
      }
    });
    return config;
  };

  normalizeChecker = function(item) {
    switch (toString.call(item)) {
      case '[object RegExp]':
        return function(string) {
          return item.test(string);
        };
      case '[object Function]':
        return item;
      default:
        throw new Error("Config item " + item + " is invalid.Use RegExp or Function.");
    }
  };

  createJoinConfig = function(configFiles) {
    var listToObj, result, types;
    listToObj = function(acc, elem) {
      acc[elem[0]] = elem[1];
      return acc;
    };
    types = Object.keys(configFiles);
    result = types.map(function(type) {
      return configFiles[type].joinTo;
    }).map(function(joinTo) {
      var object;
      if (typeof joinTo === 'string') {
        object = {};
        object[joinTo] = /.+/;
        return object;
      } else {
        return joinTo;
      }
    }).map(function(joinTo, index) {
      var makeChecker, subConfig;
      makeChecker = function(generatedFilePath) {
        return [generatedFilePath, normalizeChecker(joinTo[generatedFilePath])];
      };
      subConfig = Object.keys(joinTo).map(makeChecker).reduce(listToObj, {});
      return [types[index], subConfig];
    }).reduce(listToObj, {});
    return Object.freeze(result);
  };

  identityNode = exports.identityNode = function(code, source) {
    return new SourceNode(1, 0, null, code.split('\n').map(function(line, index) {
      return new SourceNode(index + 1, 0, source, line + '\n');
    }));
  };

  exports.cleanModuleName = cleanModuleName = function(path, nameCleaner) {
    return nameCleaner(path.replace(new RegExp('\\\\', 'g'), '/'));
  };

  getModuleWrapper = function(type, nameCleaner) {
    return function(fullPath, data, isVendor) {
      var moduleName, path, sourceURLPath;
      sourceURLPath = cleanModuleName(fullPath, nameCleaner);
      moduleName = sourceURLPath.replace(/\.\w+$/, '');
      path = JSON.stringify(moduleName);
      if (isVendor) {
        debug('Wrapping is vendor');
        return data;
      } else {
        if (type === 'commonjs') {
          return {
            prefix: "require.register(" + path + ", function(exports, require, module) {\n",
            suffix: "});\n\n"
          };
        } else if (type === 'amd') {
          return {
            data: data.replace(/define\s*\(/, function(match) {
              return "" + match + path + ", ";
            })
          };
        }
      }
    };
  };

  normalizeWrapper = function(typeOrFunction, nameCleaner) {
    switch (typeOrFunction) {
      case 'commonjs':
        return getModuleWrapper('commonjs', nameCleaner);
      case 'amd':
        return getModuleWrapper('amd', nameCleaner);
      case false:
        return function(path, data) {
          return data;
        };
      default:
        if (typeof typeOrFunction === 'function') {
          return typeOrFunction;
        } else {
          throw new Error('config.modules.wrapper should be a function or one of:\
"commonjs", "amd", false');
        }
    }
  };

  normalizeDefinition = function(typeOrFunction) {
    switch (typeOrFunction) {
      case 'commonjs':
        return function() {
          return commonRequireDefinition;
        };
      case 'amd':
      case false:
        return function() {
          return '';
        };
      default:
        if (typeof typeOrFunction === 'function') {
          return typeOrFunction;
        } else {
          throw new Error('config.modules.definition should be a function\
or one of: "commonjs", false');
        }
    }
  };

  exports.setConfigDefaults = setConfigDefaults = function(config, configPath) {
    var conventions, join, joinRoot, modules, paths, _base, _base1, _base2, _ref,
      _this = this;
    join = function(parent, name) {
      return sysPath.join(config.paths[parent], name);
    };
    joinRoot = function(name) {
      return join('root', name);
    };
    paths = config.paths != null ? config.paths : config.paths = {};
    if (paths.root == null) {
      paths.root = '.';
    }
    if (paths["public"] == null) {
      paths["public"] = joinRoot('public');
    }
    if (paths.watched == null) {
      paths.watched = ['app', 'test', 'vendor'].map(joinRoot);
    }
    if (paths.config == null) {
      paths.config = configPath != null ? configPath : joinRoot('config');
    }
    if (paths.packageConfig == null) {
      paths.packageConfig = joinRoot('package.json');
    }
    conventions = config.conventions != null ? config.conventions : config.conventions = {};
    if (conventions.assets == null) {
      conventions.assets = /assets[\\/]/;
    }
    if (conventions.ignored == null) {
      conventions.ignored = (_ref = paths.ignored) != null ? _ref : function(path) {
        return sysPath.basename(path)[0] === '_';
      };
    }
    if (conventions.vendor == null) {
      conventions.vendor = /(^bower_components|vendor)[\\/]/;
    }
    if (config.notifications == null) {
      config.notifications = true;
    }
    if (config.sourceMaps == null) {
      config.sourceMaps = true;
    }
    if (config.optimize == null) {
      config.optimize = false;
    }
    modules = config.modules != null ? config.modules : config.modules = {};
    if (modules.wrapper == null) {
      modules.wrapper = 'commonjs';
    }
    if (modules.definition == null) {
      modules.definition = 'commonjs';
    }
    if (modules.nameCleaner == null) {
      modules.nameCleaner = function(path) {
        return path.replace(/^app\//, '');
      };
    }
    if (config.server == null) {
      config.server = {};
    }
    if ((_base = config.server).base == null) {
      _base.base = '';
    }
    if ((_base1 = config.server).port == null) {
      _base1.port = 3333;
    }
    if ((_base2 = config.server).run == null) {
      _base2.run = false;
    }
    return config;
  };

  getConfigDeprecations = function(config) {
    var ensureNotArray, messages, warnMoved, warnRemoved;
    messages = [];
    warnRemoved = function(path) {
      if (config.paths[path]) {
        return messages.push("config.paths." + path + " was removed, use config.paths.watched");
      }
    };
    warnMoved = function(configItem, from, to) {
      if (configItem) {
        return messages.push("config." + from + " moved to config." + to);
      }
    };
    warnRemoved('app');
    warnRemoved('test');
    warnRemoved('vendor');
    warnRemoved('assets');
    warnMoved(config.paths.ignored, 'paths.ignored', 'conventions.ignored');
    warnMoved(config.rootPath, 'rootPath', 'paths.root');
    warnMoved(config.buildPath, 'buildPath', 'paths.public');
    ensureNotArray = function(name) {
      if (Array.isArray(config.paths[name])) {
        return messages.push("config.paths." + name + " can't be an array.Use config.conventions." + name);
      }
    };
    ensureNotArray('assets');
    ensureNotArray('test');
    ensureNotArray('vendor');
    return messages;
  };

  normalizeConfig = function(config) {
    var mod, normalized;
    normalized = {};
    normalized.join = createJoinConfig(config.files);
    mod = config.modules;
    normalized.modules = {};
    normalized.modules.wrapper = normalizeWrapper(mod.wrapper, config.modules.nameCleaner);
    normalized.modules.definition = normalizeDefinition(mod.definition);
    normalized.conventions = {};
    Object.keys(config.conventions).forEach(function(name) {
      return normalized.conventions[name] = normalizeChecker(config.conventions[name]);
    });
    config._normalized = normalized;
    return config;
  };

  exports.loadConfig = function(configPath, options, callback) {
    var config, deprecations, error, fullPath;
    if (configPath == null) {
      configPath = 'config';
    }
    if (options == null) {
      options = {};
    }
    fullPath = require.resolve(sysPath.resolve(configPath));
    delete require.cache[fullPath];
    try {
      config = require(fullPath).config;
    } catch (_error) {
      error = _error;
      throw new Error("couldn\'t load config " + fullPath + ". " + error);
    }
    setConfigDefaults(config, configPath);
    deprecations = getConfigDeprecations(config);
    if (deprecations.length > 0) {
      deprecations.forEach(logger.warn);
    }
    recursiveExtend(config, options);
    if (os.platform() === 'win32') {
      replaceConfigSlashes(config);
    }
    normalizeConfig(config);
    return readComponents('.', 'bower', function(error, bowerComponents) {
      var filesMap;
      if (error && !/ENOENT/.test(error.toString())) {
        logger.error(error);
      }
      if (bowerComponents == null) {
        bowerComponents = [];
      }
      config._normalized.bowerComponents = bowerComponents;
      filesMap = config._normalized.bowerFilesMap = {};
      bowerComponents.forEach(function(component) {
        return component.files.forEach(function(file) {
          return filesMap[file] = component.sortingLevel;
        });
      });
      deepFreeze(config);
      return callback(null, config);
    });
  };

}).call(this);
